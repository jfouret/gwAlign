#!/usr/bin/python
import argparse
gitRepository='SEDMATCHGITREPO'
version='SEDMATCHGITVERSION'
year=2016
author='Julien Fouret'
contact='julien.fouret12@uniagro.fr'
##parse argument
parser = argparse.ArgumentParser(description='Sort gene/transcript from an alignement and reassemble all exons. Get the corresponding name(NGNC) of the protein with the accession numer (from ucsc or ncbi) and add kegg, go and uniprot annotations',epilog="Version : "+str(version)+"\n"+str(year)+"\nAuthor : "+author+" for more informations or enquiries please contact "+contact,formatter_class=argparse.ArgumentDefaultsHelpFormatter)
parser.add_argument('-al', metavar='Alignment file', required=False, help="alignment file in fasta format")
parser.add_argument('-out', metavar='Output directory', required=True, help="folder in which to write all computed alignments")
parser.add_argument('-mode', metavar='create,annotate,getCDS,align', required=True, help="annotate: annoation with ucsc database; getCDS: get complete CDS; ")
parser.add_argument('-v',action='store_true', help="verbose")
parser.add_argument('-debug',action='store_true', help="verbose")
parser.add_argument('-spec', metavar='Species file' , required=False, help="tab separated file with all assembly name and assembly path (with .dict and .fai)")
parser.add_argument('-host', metavar='mysql host' , required=False, help="",default='10.0.0.200')
parser.add_argument('-port', metavar='mysql port' , required=False, help="",default='3306')
parser.add_argument('-db',metavar='Database', required=False, help="name of the database 'ncbi' or 'ucsc'",default='ucsc',choices=['ucsc','ncbi'])
parser.add_argument('-ref', metavar='ref species', required=False, help="reference species for multiple alignment",default='hg19')
parser.add_argument('-phase_filter', metavar='config file', required=False, help="",default='')
parser.add_argument('-queue', metavar='queue', required=False, help="queue for PBS",default='SEDMATCHQUEUE')
parser.add_argument('-picard', metavar='/path', required=False, help="picard jar path",default='SEDMATCHPICARD')
parser.add_argument('-genePythia', metavar='/path', default='SEDMATCHGENEPYTHIA',required=False, help="script for bibliography")
args=parser.parse_args()

import os
import sys
import mysql.connector
from Bio import SeqIO
from Bio.Seq import Seq
import re
from jupype import *

##define function
def writedb(query,file_name,header):
	global cnx
	global args
	if args.v:
		print query
		print("\n")
	cursor=cnx.cursor()
	cursor.execute(query)
	rows=cursor.fetchall()
	tab_file=open(file_name,"w")
	tab_file.write("\t".join(header))
	for row in rows:
		tab_file.write("\n")
		tab_file.write("\t".join(map(str,row)))
	tab_file.close()
	cursor.close()
def Get_annotation(ID):
	global args
	global iterNoName
	global allSymbol
	if args.db=='ucsc':
		field='kgID'
	elif args.db=='ncbi':
		field='refseq'
	#global ID_type
	query_where='WHERE (ref.'+field+'="'+ID+'");'
	query_name=['SELECT hgnc.symbol,ref.kgID,ref.spID,ref.refseq,ref.geneSymbol']
	query_name.append('FROM kgXref ref')
	query_name.append('LEFT JOIN proteinDB.hgncXref hgnc ON ( hgnc.uniProt=ref.spID ) AND (hgnc.refSeq=ref.refseq)')
	query_name.append(query_where)

	query_alias=['SELECT ref.alias']
	query_alias.append('FROM kgAlias ref')
	query_alias.append(query_where)

	query_uniprot=['SELECT ref.geneSymbol,feats.start,feats.end,class.val AS `class`,type.val AS `type`,feats.softEndBits AS `OutOfRange`']
	query_uniprot.append('FROM uniProt.feature feats')
	query_uniprot.append('LEFT JOIN kgXref ref ON (ref.spID=feats.acc)')
	query_uniprot.append('LEFT JOIN uniProt.featureClass class ON (class.id=feats.featureClass)')
	query_uniprot.append('LEFT JOIN uniProt.featureType type ON (type.id=feats.featureType)')
	query_uniprot.append(query_where)

	query_kegg=['SELECT ref.geneSymbol,kegg.mapID,des.description']
	query_kegg.append('FROM keggPathway kegg')
	query_kegg.append('LEFT JOIN kgXref ref ON (ref.kgID=kegg.kgID)')
	query_kegg.append('LEFT JOIN keggMapDesc des ON (kegg.mapID=des.mapID)')
	query_kegg.append(query_where)

	query_go=['SELECT ref.geneSymbol, goa.goId, goterm.name, goterm.term_type']
	query_go.append('FROM go.goaPart goa')
	query_go.append('LEFT JOIN kgXref ref ON (ref.spID=goa.dbObjectId)')
	query_go.append('LEFT JOIN go.term goterm ON (goa.goId=goterm.acc)')
	query_go.append(query_where)

	annotPath=rootedDir.results+"/"+ID+"/annotation/"
	mkdirp(annotPath)
	writedb(" ".join(query_name),annotPath+"/name.tab",['geneSymbol','kgID','uniprot','refSeq','kgName'])
	name_file=open(annotPath+"/name.tab","r")
	name_file_line1=name_file.readlines()[1]
	gene_symbol=name_file_line1.split("\t")[0]
	hgnc=name_file_line1.split("\t")[0]
	spID=name_file_line1.split("\t")[2]
	refseq=name_file_line1.split("\t")[3]
	kgname=name_file_line1.split("\t")[4]
	gene_symbol=hgnc
	if (hgnc=='None' or hgnc=='') or (spID=='' and refseq=='') :
		gene_symbol='kg_'+kgname
	elif kgname=='None' or kgname=='':
		gene_symbol='sp_'+spID
	elif spID=='None' or spID=='':
		gene_symbol='rs_'+refseq
	elif refseq=='None' or refseq=='':
		gene_symbol='NoID_'+str(iterNoName)
		iterNoName+=1
	gene_symbol=renameFileName(gene_symbol)
	if (gene_symbol in allSymbol.keys()):
		allSymbol[gene_symbol]+=1
		gene_symbol='dup'+str(allSymbol[gene_symbol])+'_'+gene_symbol
	else:
		allSymbol[gene_symbol]=0
	name_file.close()
	with  open(annotPath+"/consName.txt",'w') as consNameFIle:
		consNameFIle.write(gene_symbol)
	#os.system('mv '+rootedDir.results+"/"+ID+".name.tab"+' '+rootedDir.results+"/"+gene_symbol+'-'+ID+".name.tab")
	writedb(" ".join(query_uniprot),annotPath+"/uniprot.tab",['geneSymbol','start','end','class','type','OutOfRange'])
	writedb(" ".join(query_kegg),annotPath+"/kegg.tab",['geneSymbol','mapID','description'])
	writedb(" ".join(query_go),annotPath+"/go.tab",['geneSymbol','goId','name','type'])
	writedb(" ".join(query_alias),annotPath+"/alias.txt",['alias'])
	return gene_symbol
#start program

#parse args
modeList=args.mode.split(',')

### Create directories and listing...
kgPathDict=dict()
if 'create' in modeList:
	alnFileName=os.path.abspath(args.al)
	rootedDir=RootDir(args.out,pbs=True)
	rootedDir.logs.writeArgs(args)
	# iter and create and print ref.fa
	rehg19Exon1=re.compile('^>(uc\w*)(\.\d*)_hg19_1_(\d*) (\d*) (\d*) (\d*)\s?(\w+:\d+-\d+[+-]{1};?)*$')
	exons_file=open(alnFileName,'r')
	for line in exons_file.readlines():
		m=rehg19Exon1.match(line.rstrip())
		if m:
			if args.v:
				print('##Create_dirs## '+line)
			kgID=m.group(1)+m.group(2)
			path=rootedDir.results+"/"+kgID
			kgPathDict[kgID]=path
			mkdirp(path)
	with open(rootedDir.reports+'/kgPathDictFile.tab','w') as kgPathDictFile:
		for key in kgPathDict.keys():
			kgPathDictFile.write(key+"\t"+kgPathDict[key]+"\n")
	saveRoot(rootedDir)
else:
	if args.debug:
		rootedDir=RootDir(args.out,pbs=True)
		rootedDir.logs.writeArgs(args)
	else:
		rootedDir=loadRoot(args.out)
	kgPathDict=dict()
	with open(rootedDir.reports+'/kgPathDictFile.tab','r') as kgPathDictFile:
		for line in kgPathDictFile.readlines():
			key,value=line.rstrip().split("\t")
			kgPathDict[key]=value

# get CDS
#Same as annotate but picardtools and batching ...
if 'getCDS' in modeList:
	alnFileName=os.path.abspath(args.al)
	specDict=dict()
	with open(args.spec,'r') as species_file:
		for line in species_file.readlines():
			if args.v:
				print('##Parsing species## '+line)
			if line.rstrip()!='':
				specie,assembly=line.rstrip().split("\t")
				specDict[specie]=assembly
	java=Command('java')
	#java.log()
	picard_cmd=java.create(options={'-XX:ParallelGCThreads=1 -jar':args.picard})
	picard=Command(picard_cmd,picard_cmd+' CheckFingerprint --version 2>&1 | sed \'s/(.*$//g\'')
	#picard.log()
	reID=re.compile('^(uc\w*)(\.\d*)_(\w*)_(\d*)_(\d*) (\d*) (\d*) (\d*)\s*(\w+.*)?$')
	fasta_sequences = SeqIO.parse(open(alnFileName),'fasta')
	cmdList=list()
	iterBatch=1
	Nlim=10
	N=0
	init=True

	# step 1 - iteration over exon file
	for fasta in fasta_sequences:
		# step 1.2 - get name and sequence
		name, sequence = fasta.description, str(fasta.seq)
		m=reID.match(name)
		if m and (m.group(3) in specDict.keys()):
			spec=m.group(3)
			kgID=m.group(1)+m.group(2)
			if init:
				oldkgID=kgID
				init=False

			elif kgID!=oldkgID:
				if args.v:
					print('##kg Iteration##'+str(N))
				oldkgPath=kgPathDict[oldkgID]
				for key in specDict.keys():
					oldRegFileName=oldkgPath+'/'+key+'/region.list'
					#TODO si regionlist exist
					if os.path.isfile(oldRegFileName+'.tmp'):
						getRefOpt={
							'R':specDict[key],
							'O':oldkgPath+'/'+key+'/cds.fa',
							'INTERVAL_LIST':oldRegFileName,
							'VERBOSITY':'ERROR',
							'QUIET':'true'
						}
						cmdList.append('cat '+specDict[key].rstrip('fa').rstrip('fasta').rstrip('fna')+'dict '+oldRegFileName+'.tmp'+' > '+oldRegFileName+' ; rm '+oldRegFileName+'.tmp')
						cmdList.append(picard.create(options=getRefOpt,subprogram='ExtractSequences',sep='='))
						cmdList.append('rm '+oldRegFileName)
				N+=1
				oldkgID=kgID

			if N==Nlim:
				batchName='gwAlign_getCDS_'+str(iterBatch)
				submitQsubWithPBS(createPBS(cmdList,batchName,queue=args.queue,ppn='3',workdir=rootedDir.results))
				cmdList=list()
				iterBatch+=1
				N=0
			mkdirp(kgPathDict[kgID]+'/'+spec)
			if m.group(9)==None:
				mkdirp(kgPathDict[kgID]+'/'+spec+'/missingExon'+m.group(4))
				cmdList.append('echo ">'+'exon_'+m.group(4)+"\n"+'---" > '+kgPathDict[kgID]+'/'+spec+'/missingExon'+m.group(4)+'/cds.fa')
			elif m.group(9)=='mapped':
				cmdList.append('echo ">'+'exon_'+m.group(4)+"\n"+sequence+'" >>'+kgPathDict[kgID]+'/'+spec+'/cds.fa')
			else:
				regionList=m.group(9).split(';')
				regFileName=kgPathDict[kgID]+'/'+spec+'/region.list'
				numExt=0
				for region in regionList:
					numExt+=1
					chromosome,positions=region.split(':')
					start,end=positions[:-1].split('-')
					strand=positions[-1]
					if int(start)>int(end):
						mkdirp(kgPathDict[kgID]+'/'+spec+'/rearrangedExon'+m.group(4)+'_ext'+str(numExt))
						cmdList.append('echo ">'+'exon_'+m.group(4)+'_ext'+str(numExt)+"\n"+sequence+'" >>'+kgPathDict[kgID]+'/'+spec+'/rearrangedExon'+m.group(4)+'_ext'+str(numExt)+'/cds.fa')
					else:
						with open(regFileName+'.tmp','a') as regFile:
							regFile.write("\t".join([chromosome,start,end,strand,'exon_'+m.group(4)+'_ext'+str(numExt)])+"\n")
	if N!=0:
		batchName='gwAlign_getCDS_'+str(iterBatch)
		submitQsubWithPBS(createPBS(cmdList,batchName,queue=args.queue,ppn='2',workdir=rootedDir.results))

if 'align' in modeList:
	alignCDS=gitCommand(Git(gitRepository),'alignCDS.py','bin')
	alignCDS.log()
	cmdList=list()
	N=0
	Nlim=10
	iterBatch=1
	for key in kgPathDict.keys():
		optAlign={
			'-gene_dir':kgPathDict[key],
			'-ref':args.ref,
			'-only_size':'' # TODO TEMP
		}
		cmdList.append(alignCDS.create(kgPathDict[key],optAlign))
		N+=1
		if N==Nlim:
			batchName='gwAlign_alignCDS_'+str(iterBatch)
			submitQsubWithPBS(createPBS(cmdList,batchName,queue=args.queue,ppn='1',workdir=rootedDir.results))
			cmdList=list()
			N=0
			iterBatch+=1
	if N!=0:
		batchName='gwAlign_alignCDS_'+str(iterBatch)
		submitQsubWithPBS(createPBS(cmdList,batchName,queue=args.queue,ppn='1',workdir=rootedDir.results))

if 'phase_filter' in modeList:
	phaseBlocks=gitCommand(Git(gitRepository),'phasingBlocks.py','bin')
	phaseBlocks.log()
	cmdList=list()
	N=0
	Nlim=100
	iterBatch=1
	with open(args.phase_filter,'r') as configFile:
		filterDict=dict()
		for line in configFile.readlines():
			line=line.rstrip()
			m=re.match('>(.*)',line)
			if m:
				filterName=m.group(1)
				filterDict[filterName]=dict()
			elif line!='#':
				lineList=line.split('=')
				filterDict[filterName][lineList[0]]=lineList[1]
	for filterName in filterDict.keys():
		optPhaseBlocks={
				'-gene_dir':kgPathDict[key],
				'-ref':args.ref,
				'-name':filterName
		}
		for opt in filterDict[filterName].keys():
			optPhaseBlocks['-'+opt]=filterDict[filterName][opt]
		
		for kgID in kgPathDict.keys():
			optPhaseBlocks['-gene_dir']=kgPathDict[kgID]
			cmdList.append(phaseBlocks.create(kgPathDict[kgID],optPhaseBlocks))
			N+=1
			if N==Nlim:
				batchName='gwAlign_phasing_'+str(iterBatch)
				submitQsubWithPBS(createPBS(cmdList,batchName,queue=args.queue,ppn='1',workdir=rootedDir.results))
				cmdList=list()
				N=0
				iterBatch+=1
		if N!=0:
			batchName='gwAlign_phasing_'+str(iterBatch)
			submitQsubWithPBS(createPBS(cmdList,batchName,queue=args.queue,ppn='1',workdir=rootedDir.results))

if 'stat_phasing' in modeList:
	with open(args.phase_filter,'r') as configFile:
		filterDict=dict()
		for line in configFile.readlines():
			line=line.rstrip()
			m=re.match('>(.*)',line)
			if m:
				filterName=m.group(1)
				filterDict[filterName]=dict()
			elif line!='#':
				lineList=line.split('=')
				filterDict[filterName][lineList[0]]=lineList[1]
	for filterName in filterDict.keys():
		with open(rootedDir.reports+'/'+filterName+'_stat.tab','w') as statFile:
			statFile.write("\t".join(['kgID','before','after'])+"\n")
			for kgID in kgPathDict.keys():
				alnFileName=kgPathDict[kgID]+'/'+filterName+'/codon_aln.fa'
				alnBlockFileName=kgPathDict[kgID]+'/'+filterName+'/codon_aln_blocks.fa'
				if os.path.isfile(alnFileName) and os.path.isfile(alnBlockFileName):
					with open(alnFileName) as alnFile:
						line=alnFile.readline()
						line=alnFile.readline()
						beforeLen=str(len(line.rstrip()))
					with open(alnBlockFileName) as alnBlockFile:
						line=alnBlockFile.readline()
						line=alnBlockFile.readline()
						afterLen=str(len(line.rstrip()))
				else:
					afterLen='NA'
					beforeLen='NA'
				statFile.write("\t".join([kgID,beforeLen,afterLen])+"\n")

### Annotation
if 'annotate' in modeList:
	allSymbol=dict()
	iterNoName=1
	cnx = mysql.connector.connect(user='genome',host=args.host,port=args.port,database='hg19')
	for key in kgPathDict.keys():
		gene_name=Get_annotation(key)
	cnx.close()
	with open(rootedDir.reports+'/all_withCounts.txt','w') as logFile:
		for key in allSymbol:
			logFile.write(key+"\t"+str(allSymbol[key])+"\n")
	with open(rootedDir.reports+'/duplicate.txt','w') as logFile:
		for key in allSymbol:
			if allSymbol[key]>0:
				logFile.write(key+"\n")
	submitOneShell('cd '+rootedDir.path+' ; for kgID in $(ls results) ; do echo -e "$kgID\t$(cat results/$kgID/annotation/consName.txt)" ; done > reports/consName.tab')
	submitOneShell('cd '+rootedDir.reports+' ; for path in $(awk \'{ print $2 }\' kgPathDictFile.tab); do cat $path/annotation/consName.txt | sed -r "s/$/\t$(echo $path | sed \'s/\//\\\//g\')\n/g" ; done > consNameDict.tab')
## end of annotation

if 'biblio' in modeList:
	Nbiblio=0
	Nlim=20
	reGeneName=re.compile('^(dup[0-9]+_)*([kg_]*[rs_]*[sp_]*)(.*)$')
	genepythiaGit=Git(args.genePythia)
	genepythia=gitCommand(genepythiaGit,'genePythia.py')
	genepythia.log()
	cmdList=list()
	batch=1
	for key in kgPathDict.keys():
		annotPath=kgPathDict[key]+'/annotation'
		Nbiblio+=1
		mkdirp(annotPath+'/biblio')
		os.chdir(annotPath+'/biblio')
		cmdList.append('cd '+annotPath+'/biblio')
		prefixTerm={
			'hennipa':'\'Nipah,Hendra,henipavirus\'',
			'paramyxo':'\'Nipah,Hendra,henipavirus,paramyxovirus,paramyxoviridae\''
		}
		with open('../consName.txt','r')as consNameFile:
			consName=consNameFile.readline().rstrip()
		for prefix,term in prefixTerm.iteritems():
			options={
				'-gene':reGeneName.match(consName).group(3),
				'-alias':'../alias.txt',
				'-prefix':prefix,
				'-term':term
			}
			cmdList.append(genepythia.create(annotPath+'/biblio',options))
		if Nbiblio>Nlim:
			Nbiblio=0
			batchName='Biblio_'+str(batch)
			submitQsubWithPBS(createPBS(cmdList,batchName,queue=args.queue,ppn='1',workdir=annotPath+'/biblio'))
			cmdList=list()
			batch+=1
	if Nbiblio!=0:
		Nbiblio=0
		batchName='Biblio_'+str(batch)
		submitQsubWithPBS(createPBS(cmdList,batchName,queue=args.queue,ppn='1',workdir=annotPath+'/biblio'))

saveRoot(rootedDir)
sys.exit(0)


